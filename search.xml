<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面朝大海,春暖花开</title>
    <url>/first_blog/</url>
    <content><![CDATA[<img src="https://up.enterdesk.com/edpic_source/59/f1/47/59f14794f3ddbf87b53744b3b26009f5.jpg" width="600" height="160" alt="图片名称" align="center">

<center>
<font size="4">
    从明天起，做一个幸福的人<br>
    喂马，劈柴，周游世界<br>
    从明天起，关心粮食和蔬菜<br>
    我有一所房子，面朝大海，春暖花开<br>
    <span id="more"></span>
    从明天起，和每一个亲人通信<br>
    告诉他们我的幸福<br>
    那幸福的闪电告诉我的<br>
    我将告诉每一个人<br>
    给每一条河每一座山取一个温暖的名字<br>
    陌生人，我也为你祝福<br>
    愿你有一个灿烂的前程<br>
    愿你有情人终成眷属<br>
    愿你在尘世获得幸福<br>
    我只愿面朝大海，春暖花开<br>
</font>
</center>

]]></content>
      <categories>
        <category>美句赏析</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>顾城最经典的十首短诗</title>
    <url>/gucheng/</url>
    <content><![CDATA[<img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1233674180,366516919&fm=26&gp=0.jpg" width="600" height="160" alt="图片名称" align="center">

<center>
<font size="4">
    《远和近》<br>
    你<br>
    一会看我<br>
    一会看云<br>
    我觉得<br>
    你看我时很远<br>
    你看云时很近<br>
    
    <span id="more"></span>
    <br>    
    <br>
    《一代人》<br>
    黑夜给了我黑色的眼睛<br>
    我却用它寻找光明<br>
    <br>
    <br>
    
    《微微的希望》<br>
    我和无数，不能孵化的卵石<br>
    垒在一起，蓝色的河溪爬来<br>
    把我们吞没，又悄悄吐出<br>
    没有别的，只希望草能够延长<br>
    它的影子<br>
    <br>
    <br>
    
    
    <img src="https://pic2.zhimg.com/80/v2-cabd874bc947615d174339e7715370d2_720w.jpg?source=1940ef5c" width="600" height="160" alt="图片名称" align="center">
    《雨行》<br>
    云 灰灰的<br>
    再也洗不干净<br>
    我们打开雨伞<br>
    索性涂黑了天空<br>
    在缓缓飘动的夜里<br>
    有两对双星<br>
    似乎没有定轨<br>
    只是时远时近……<br>
    <br>
    <br>
    
    《小巷》<br>
    小巷<br>
    又弯又长<br>
    没有门<br>
    没有窗<br>
    我拿把旧钥匙<br>
    敲着厚厚的墙<br>
    <br>
    <br>
    
    《规避》<br>
    穿过肃立的岩石<br>
    我走向海岸<br>
    你说吧<br>
    我懂全世界的语言<br>
    海笑了<br>
    给我看<br>
    会游泳的鸟<br>
    会飞的鱼<br>
    会唱歌的沙滩<br>
    对那永恒的质疑<br>
    却不发一言<br>
    <br>
    <br>
    <img src="https://pic1.zhimg.com/80/v2-c2ec8f4c39d16cc85e0589c05ef9a1cf_720w.jpg?source=1940ef5c" width="600" height="160" alt="图片名称" align="center">
    《奠》<br>
    我把你的誓言<br>
    把爱<br>
    刻在蜡烛上<br>
    看它怎样<br>
    被泪水淹没<br>
    被心火烧完<br>
    看那最后一念<br>
    怎样灭绝<br>
    怎样被风吹散<br>
    <br>
    <br>
    
    《门前》<br>
    我多么希望，有一个门口<br>
    早晨，阳光照在草上<br>
    我们站着<br>
    扶着自己的门窗<br>
    门很低，但太阳是明亮的<br>
    草在结它的种子<br>
    风在摇它的叶子<br>
    我们站着，不说话<br>
    就十分美好<br>
    有门，不用开开<br>
    是我们的，就十分美好<br>
    早晨，黑夜还要流浪<br>
    我们把六弦琴交给他<br>
    我们不走了<br>
    我们需要土地<br>
    需要永不毁灭的土地<br>
    我们要乘着它<br>
    度过一生<br>
    土地是粗糙的，有时狭隘<br>
    然而，它有历史<br>
    有一份天空，一份月亮<br>
    一份露水和早晨<br>
    我们爱土地<br>
    我们站着<br>
    用木鞋挖着泥土<br>
    门也晒热了<br>
    我们轻轻靠着，十分美好<br>
    墙后的草<br>
    不会再长大了<br>
    它只用指尖 触了触阳光<br>
    <br>
    
</font>
</center>

]]></content>
      <categories>
        <category>美句赏析</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/singleton/</url>
    <content><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>注意:</p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	&#x2F;**</span><br><span class="line"> * 饿汉式</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance &#x3D; new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static Singleton getInstance()&#123;</span><br><span class="line">        return  instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	&#x2F;**</span><br><span class="line"> * 懒汉式</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Singleton &#123;</span><br><span class="line"></span><br><span class="line">    private static Singleton instance &#x3D; null;</span><br><span class="line">    </span><br><span class="line">    private Singleton()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized Singleton getInstance()&#123;</span><br><span class="line">        </span><br><span class="line">        if (instance &#x3D;&#x3D; null)&#123;</span><br><span class="line">            instance &#x3D; new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>你好,旧时光</title>
    <url>/mylife/</url>
    <content><![CDATA[<img src="http://images.haozd.cn/1908/1_190820112607_1.jpg" width="600" height="160" alt="图片名称" align="center">

<center>
<font size="4">
    去见你想见的人吧<br>
    趁阳光正好，趁微风不噪<br>
    <span id="more"></span>
    趁繁花还未开至荼蘼<br>
    趁现在还年轻还可以走很长很长的路<br>
    还能诉说很深很深的思念<br>
    趁世界还不那么拥挤<br>
    趁飞机还没有起飞<br>
    趁现在自己的双手还能拥抱彼此<br>
    趁我们还有呼吸<br>
</font>
</center>

]]></content>
      <categories>
        <category>美句赏析</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机的前世今生和Java内存区域</title>
    <url>/jvm_01/</url>
    <content><![CDATA[<h1 id="1-JVM-的内存区域"><a href="#1-JVM-的内存区域" class="headerlink" title="1. JVM 的内存区域"></a>1. JVM 的内存区域</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>运行时数据区的定义：Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域<br>Java 引以为豪的就是它的自动内存管理机制。相比于 C++的手动内存管理、复杂难以理解的指针等，Java 程序写起来就方便的多。<br>所以要深入理解 JVM 必须理解内存虚拟化的概念。<br>在 JVM 中，JVM 内存主要分为堆、程序计数器、方法区、虚拟机栈和本地方法栈等。<br>同时按照与线程的关系也可以这么划分区域：<br>线程私有区域：一个线程拥有单独的一份内存区域。<br>线程共享区域：被所有线程共享，且只有一份。<br>这里还有一个直接内存，这个虽然不是运行时数据区的一部分，但是会被频繁使用。你可以理解成没有被虚拟机化的操作系统上的其他内存（比如操作 系统上有 8G 内存，被 JVM 虚拟化了 3G，那么还剩余 5G， JVM 是借助一些工具使用这 5G 内存的，这个内存部分称之为直接内存）<br><img src="/images/run_data.jpg"></p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p><strong>栈的数据结构：</strong>先进后出(FILO)的数据结构，<br><strong>虚拟机栈的作用：</strong>在 JVM 运行过程中存储当前线程运行方法所需的数据，指令、返回地址。<br><strong>虚拟机栈是基于线程的：</strong>哪怕你只有一个 main() 方法，也是以线程的方式运行的。在线程的生命周期中，参与计算的数据会频繁地入栈和出栈，栈的生 命周期是和线程一样的。<br>虚拟机栈的大小缺省为 1M，可用参数 –Xss 调整大小，例如-Xss256k。<br><strong>栈帧：</strong>在每个 Java 方法被调用的时候，都会创建一个栈帧，并入栈。一旦方法完成相应的调用，则出栈。<br><strong>栈帧大体都包含四个区域：</strong>(局部变量表、操作数栈、动态连接、返回地址)<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>1、 局部变量表：</strong><br>顾名思义就是局部变量的表，用于存放我们的局部变量的（方法中的变量）。首先它是一个 32 位的长度，主要存放我们的 Java 的八大基础数据类 型，一般 32 位就可以存放下，如果是 64 位的就使用高低位占用两个也可以存放下，如果是局部的一些对象，比如我们的 Object 对象，我们只需要存放它的一个引用地址即可。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>2、 操作数据栈：</strong><br>存放 java 方法执行的操作数的，它就是一个栈，先进后出的栈结构，操作数栈，就是用来操作的，操作的的元素可以是任意的 java 数据类型，所 以我们知道一个方法刚刚开始的时候，这个方法的操作数栈就是空的。 操作数栈本质上是 JVM 执行引擎的一个工作区，也就是方法在执行，才会对操作数栈进行操作，如果代码不不执行，操作数栈其实就是空的。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>3、 动态连接：</strong><br>Java 语言特性多态（后续章节细讲，需要结合 class 与执行引擎一起来讲）。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>4、 返回地址：</strong><br>正常返回（调用程序计数器中的地址作为返回）、异常的话（通过异常处理器表&lt;非栈帧中的&gt;来确定） 同时，虚拟机栈这个内存也不是无限大，它有大小限制，默认情况下是 1M。 如果我们不断的往虚拟机栈中入栈帧，但是就是不出栈的话，那么这个虚拟机栈就会爆掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StackError &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        A();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public static void A()&#123;</span><br><span class="line">        A();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Exception in thread “main” java.lang.StackOverflowError</p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响。<br>&nbsp;&nbsp;&nbsp;&nbsp;程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。 由于 Java 是多线程语言，当执行的线程数量超过 CPU 核数时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。<br>&nbsp;&nbsp;&nbsp;&nbsp;因为 JVM 是虚拟机，内部有完整的指令与执行的一套流程，所以在运行 Java 方法的时候需要使用程序计数器（记录字节码执行的地址或行号），如果 是遇到本地方法（native 方法），这个方法不是 JVM 来具体执行，所以程序计数器不需要记录了，这个是因为在操作系统层面也有一个程序计数器，这个 会记录本地代码的执行的地址，所以在执行 native 方法时，JVM 中程序计数器的值为空(Undefined)。<br>&nbsp;&nbsp;&nbsp;&nbsp;另外程序计数器也是 JVM 中唯一不会 OOM(OutOfMemory)的内存区域</p>
<h1 id="栈帧执行对内存区域的影响"><a href="#栈帧执行对内存区域的影响" class="headerlink" title="栈帧执行对内存区域的影响"></a>栈帧执行对内存区域的影响</h1><p>对 class 进行反汇编 javap –c XXXX.class<br><img src="/images/run_data_2.jpg"><br>在 JVM 中，基于解释执行的这种方式是基于栈的引擎，这个说的栈，就是操作数栈。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
</search>
